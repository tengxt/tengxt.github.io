---
layout:     post
title:      "NIO学习笔记"
subtitle:   "进一寸有进一寸的欢喜"
date:       2020-09-22 22:50:00
author:     "Xt"
header-style: text
tags:
    - NIO
    - New IO
---

Java NIO（`New IO`或 `Non Blocking IO`）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO支持面向缓冲区的、基于通道的 IO 操作。NIO 将以更加高效的方式进行文件的读写操作。

Java IO 和 Java NIO 的区别

| IO                      | NIO                         |
| ----------------------- | --------------------------- |
| 面向流(Stream Oriented) | 面向缓冲区(Buffer Oriented) |
| 阻塞IO(Blocking IO)     | 非阻塞IO(Non Blocking IO)   |
| 无                      | 选择器(Selectors)           |

### 一、通道（Channel）与缓冲区（Buffer）

若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，`Channel` 负责传输， `Buffer` 负责存储。

#### 1、缓冲区（Buffer）

缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 `Java.nio` 包定义的，所有缓冲区都是 `Buffer` 抽象类的子类。
Java NIO 中的`Buffer`主要用于与 `NIO` 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。

![nio_20170306220636876.png](..\..\..\..\..\img\07\nio_20170306220636876.png)

**Buffer 的常用方法**

| 方法                   | 概述                                                      |
| ---------------------- | --------------------------------------------------------- |
| Buffer clear()         | 清空缓冲区并返回对缓冲区的引用                            |
| Buffer flip()          | 将缓冲区的界限设置为当前位置，并将当前位置重置为0         |
| int capacity()         | 返回 Buffer 的 capacity 大小                              |
| boolean hasRemaining() | 判断缓冲区中是否还有元素                                  |
| int limit()            | 返回 Buffer 的界限（limit）的位置                         |
| Buffer limit(int n)    | 将设置缓冲区界限为 n，并返回一个具有新 limit 的缓冲区对象 |
| Buffer mark()          | 对缓冲区设置标记                                          |
| int position()         | 返回缓冲区的当前位置 position                             |
| Buffer position(int n) | 将设置缓冲区的当前位置为n，并返回修改后的 Buffer 对象     |
| int remaining()        | 返回 position 和 limit 之间的元素个数                     |
| Buffer reset()         | 将位置 position 转到以前设置的 mark 所在的位置            |
| Buffer rewind()        | 将位置设定为0，取消设置的 mark                            |

```java
@Test
public void test2() {
    String str = "abcde";
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    buffer.put(str.getBytes());

    buffer.flip();
    byte[] dist = new byte[buffer.limit()];
    buffer.get(dist, 0, 2);
    System.out.println(new String(dist, 0, 2)); // ab
    System.out.println(buffer.position()); // 2

    // mark():  标记
    buffer.mark();

    buffer.get(dist, 2, 2);
    System.out.println(new String(dist, 2, 2)); // cd
    System.out.println(buffer.position()); // 4

    // reset(): 恢复到 mark 的位置
    buffer.reset();
    System.out.println(buffer.position()); // 2

    // 判断缓冲区是否还有剩余数据
    if (buffer.hasRemaining()) {
        // 获取缓冲区中可以操作的数量
        System.out.println(buffer.remaining());
    }
}


@Test
public void test1() {
    // 1. 分配一个指定大小的缓冲区
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    System.out.println("----------allocate()----------");
    System.out.println(buffer.position());  // 0
    System.out.println(buffer.limit());     // 1024
    System.out.println(buffer.capacity());  // 1024

    // 2. 利用 put() 存入数据到缓冲区中
    String str = "abcde";

    buffer.put(str.getBytes());
    System.out.println("----------put()----------");
    System.out.println(buffer.position());  // 5
    System.out.println(buffer.limit());     // 1024
    System.out.println(buffer.capacity());  // 1024

    // 3. flip() 切换读取数据模式
    buffer.flip();
    System.out.println("----------flip()----------");
    System.out.println(buffer.position());  // 0
    System.out.println(buffer.limit());     // 5
    System.out.println(buffer.capacity());  // 1024

    // 4. 利用get() 读取数据缓冲区中的数据
    byte[] dst = new byte[buffer.limit()];
    buffer.get(dst);

    System.out.println("----------get()----------");
    System.out.println(new String(dst, 0, dst.length));   //abcde

    System.out.println(buffer.position());  // 5
    System.out.println(buffer.limit());     // 5
    System.out.println(buffer.capacity());  // 1024

    // 5. rewind() ： 可重复读数据
    buffer.rewind();
    System.out.println("----------rewind()----------");
    System.out.println(buffer.position());  // 0
    System.out.println(buffer.limit());     // 5
    System.out.println(buffer.capacity());  // 1024

    // 6. clear() : 清空缓冲区，但是缓冲区的数据依然存在，但是处于“被遗忘”状态
    buffer.clear();
    System.out.println("----------clear()----------");
    System.out.println(buffer.position());  // 0
    System.out.println(buffer.limit());     // 1024
    System.out.println(buffer.capacity());  // 1024

    System.out.println((char) buffer.get());
}
```

**非直接缓冲区**

通过 `allocate()` 分配缓冲区，将缓冲区建立在 JVM 的内存中

```java
// 分配一个指定大小的缓冲区
ByteBuffer buffer = ByteBuffer.allocate(1024);
```

**直接缓冲区**

通过 `allocateDirect() `分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率

```java
// 分配直接缓冲区
ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
// 判断是否直接缓冲区
System.out.println(buffer.isDirect());
```

#### 2、通道（Channel）

`Channel`表示 IO 源与目标打开的连接, `Channel` 类似于传统的“流”。但其自身不能直接访问数据，`Channel`只能与 `Buffer`进行交互。

**FileChannel 的常用方法**

| 方法                          | 描述                                         |
| ----------------------------- | -------------------------------------------- |
| int read(ByteBuffer dst)      | 从 Channel 中读取到 ByteBuffer               |
| long read(ByteBuffer[] dsts)  | 将 Channel 中的数据 ”分散“ 到 ByteBuffer[]   |
| int write(ByteBuffer src)     | 将 ByteBuffer 中的数据写入到 Channel         |
| long write(ByteBuffer[] srcs) | 将 ByteBuffer[] 中的数据 ”聚集“ 到 Channel   |
| long position()               | 返回此通道的文件位置                         |
| FileChannel position(long p)  | 设置此通道的文件位置                         |
| long size()                   | 返回此通道的文件的当前大小                   |
| FileChannel truncate(long s)  | 将此通道的文件截取为给定大小                 |
| void force(boolean metaData)  | 强制将所有对此通道的文件更新写入到存储设备中 |

**获取通道**

1. Java 针对支持通道的类提供了 `getChannel() `方法

   ```java
   // 利用通道完成文件的复制(非直接缓冲区)
   @Test
   public void test1() {
       long start = System.currentTimeMillis();
       try {
           FileInputStream fis = new FileInputStream("E:/1.jpg");
           FileOutputStream fos = new FileOutputStream("E:/2.jpg");
           // 1. 获取通道
           FileChannel inChannel = fis.getChannel();
           FileChannel outChannel = fos.getChannel();
           // 2. 分配指定大小的缓冲区
           ByteBuffer buffer = ByteBuffer.allocate(1024);
           // 3. 将通道中的数据存入缓冲区
           while (inChannel.read(buffer) != -1) {
               // 切换读取数据的模式
               buffer.flip();
               // 4. 将缓冲区中的数据写入通道中
               outChannel.write(buffer);
               // 清空缓冲区
               buffer.clear();
           }
           // 关闭连接
           outChannel.close();
           inChannel.close();
           fos.close();
           fis.close();
       } catch (Exception e) {
           e.printStackTrace();
       }
   }
   ```

2. 在 JDk 1.7 中的 NIO.2 针对各个通道提供了静态方法 `open()`方法

   ```java
   // 使用直接缓冲区完成文件的复制(内存映射文件)
   @Test
   public void test2() {
       try {
           FileChannel inChannel = FileChannel.open(
				Paths.get("E:/1.jpg"), 
				StandardOpenOption.READ);
           FileChannel outChannel = FileChannel.open(
				Paths.get("E:/2.jpg"),
				StandardOpenOption.WRITE, 
				StandardOpenOption.READ, 
				StandardOpenOption.CREATE);
   
           // 内存映射文件
           MappedByteBuffer inMappedBuf = inChannel.map(
				FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
           MappedByteBuffer outMappedBuf = outChannel.map(
				FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
   
           // 直接对缓冲区进行数据的读写操作
           byte[] dst = new byte[inMappedBuf.limit()];
           inMappedBuf.get(dst);
           outMappedBuf.put(dst);
   
           //  关闭连接
           outChannel.close();
           inChannel.close();
       } catch (IOException e) {
           e.printStackTrace();
       }
   }
   
   // 通道之间的数据传输(直接缓冲区)
   @Test
   public void test3() {
       long start = System.currentTimeMillis();
       try {
           FileChannel inChannel = FileChannel.open(
				Paths.get("E:/1.jpg"), 
				StandardOpenOption.READ);
           FileChannel outChannel = FileChannel.open(
				Paths.get("E:/2.jpg"),
                StandardOpenOption.WRITE, 
				StandardOpenOption.READ, 
				StandardOpenOption.CREATE);
   
           // inChannel.transferTo(0, inChannel.size(), outChannel);
           outChannel.transferFrom(inChannel, 0, inChannel.size());
   
           //  关闭连接
           outChannel.close();
           inChannel.close();
       } catch (IOException e) {
           e.printStackTrace();
       }
       long end = System.currentTimeMillis();
       System.out.println("耗费时间：" + (end - start));//耗费时间：15
   }
   ```

3. 在 JDK 1.7 中的 NIO.2 的 Files 工具类的 `newByteChannel()`方法


> [source](https://github.com/tengxt/Java-basics/tree/master/Java-nio/src)
> 
> [参考链接](https://blog.csdn.net/zxm1306192988/article/details/60581173)





